/**
 * Packager â€” Export Forge outputs as standalone PWA apps.
 * 
 * IT-16: Takes generated HTML and wraps it in a fully offline-capable
 * Progressive Web App with service worker + manifest.
 * 
 * "The more an individual can do, the more reality it possesses." â€” Spinoza
 * Packaging = giving your creation the power to exist independently.
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'node:fs';
import { join, basename, dirname } from 'node:path';

/**
 * Generate a PWA manifest.json
 */
export function generateManifest(opts = {}) {
  return {
    name: opts.name || 'Forge App',
    short_name: opts.shortName || 'Forge',
    description: opts.description || 'Generated by MODUS Forge',
    start_url: './index.html',
    display: 'standalone',
    background_color: opts.bgColor || '#0a0a0f',
    theme_color: opts.themeColor || '#7C3AED',
    icons: [
      {
        src: `data:image/svg+xml,${encodeURIComponent(generateIcon(opts.emoji || 'ðŸ”¥'))}`,
        sizes: 'any',
        type: 'image/svg+xml',
      },
    ],
  };
}

/**
 * Generate a simple SVG icon from an emoji
 */
export function generateIcon(emoji) {
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100">
  <rect width="100" height="100" rx="20" fill="#0a0a0f"/>
  <text x="50" y="70" font-size="60" text-anchor="middle">${emoji}</text>
</svg>`;
}

/**
 * Generate a minimal service worker for offline support
 */
export function generateServiceWorker(cacheName) {
  const cn = cacheName || `forge-${Date.now()}`;
  return `// Forge PWA Service Worker â€” ${cn}
const CACHE = '${cn}';
const ASSETS = ['./index.html'];

self.addEventListener('install', e => {
  e.waitUntil(caches.open(CACHE).then(c => c.addAll(ASSETS)));
  self.skipWaiting();
});

self.addEventListener('activate', e => {
  e.waitUntil(caches.keys().then(keys =>
    Promise.all(keys.filter(k => k !== CACHE).map(k => caches.delete(k)))
  ));
  self.clients.claim();
});

self.addEventListener('fetch', e => {
  e.respondWith(
    caches.match(e.request).then(r => r || fetch(e.request).catch(() =>
      caches.match('./index.html')
    ))
  );
});
`;
}

/**
 * Inject PWA registration into HTML
 */
export function injectPWA(html) {
  const pwaSnippet = `
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#7C3AED">
<script>
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('./sw.js').catch(() => {});
}
</script>`;

  // Inject before </head> or at end
  if (html.includes('</head>')) {
    return html.replace('</head>', `${pwaSnippet}\n</head>`);
  }
  return html + pwaSnippet;
}

/**
 * Package a generated HTML file into a standalone PWA directory
 * 
 * @param {string} htmlPath - Path to the generated HTML file
 * @param {string} outDir - Output directory for the PWA
 * @param {object} opts - Options (name, emoji, description)
 * @returns {object} - { dir, files } 
 */
export function packageAsPWA(htmlPath, outDir, opts = {}) {
  const html = readFileSync(htmlPath, 'utf-8');
  
  // Extract title from HTML if not provided
  const titleMatch = html.match(/<title>([^<]+)<\/title>/i);
  const name = opts.name || (titleMatch ? titleMatch[1] : 'Forge App');
  
  mkdirSync(outDir, { recursive: true });
  
  const manifest = generateManifest({ ...opts, name });
  const sw = generateServiceWorker(`forge-${basename(outDir)}`);
  const pwaHtml = injectPWA(html);
  
  const files = {
    'index.html': pwaHtml,
    'manifest.json': JSON.stringify(manifest, null, 2),
    'sw.js': sw,
  };
  
  for (const [file, content] of Object.entries(files)) {
    writeFileSync(join(outDir, file), content, 'utf-8');
  }
  
  return { dir: outDir, files: Object.keys(files), name };
}

/**
 * Package as a single self-contained HTML file (no external deps)
 * Inlines everything into one file â€” maximum portability.
 */
export function packageAsStandalone(htmlPath, outPath) {
  const html = readFileSync(htmlPath, 'utf-8');
  
  // Add offline meta + viewport if missing
  let result = html;
  if (!result.includes('viewport')) {
    result = result.replace('<head>', '<head>\n<meta name="viewport" content="width=device-width, initial-scale=1">');
  }
  
  // Already self-contained (inline styles/scripts) â€” just copy with metadata
  const header = `<!-- Generated by MODUS Forge | ${new Date().toISOString()} | Standalone Export -->\n`;
  result = header + result;
  
  const dir = dirname(outPath);
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
  writeFileSync(outPath, result, 'utf-8');
  
  return { path: outPath, size: Buffer.byteLength(result) };
}
