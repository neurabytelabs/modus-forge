/**
 * Share ‚Äî Export/import Forge creations as "Spell Packs".
 * 
 * IT-16: A spell pack captures the full creation context:
 * prompt, RUNE enhancement, context signals, provider, output, scores.
 * Import a spell pack to recreate or remix someone else's generation.
 * 
 * "No one can desire to be blessed, to act well, and to live well,
 *  who does not at the same time desire to be, to act, and to live." ‚Äî Spinoza
 * Sharing is how ideas persist beyond their creator.
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'node:fs';
import { join, dirname } from 'node:path';

const SPELL_VERSION = '1.0';

/**
 * Create a spell pack from a forge generation result.
 * 
 * @param {object} result - Forge pipeline result
 * @param {object} opts - Additional metadata
 * @returns {object} spell pack
 */
export function createSpellPack(result, opts = {}) {
  return {
    _format: 'modus-forge-spell',
    _version: SPELL_VERSION,
    created: new Date().toISOString(),
    author: opts.author || 'anonymous',
    
    // The spell itself
    prompt: result.prompt || opts.prompt,
    enhanced: result.enhanced || null,
    
    // Context at creation time (anonymized)
    context: anonymizeContext(result.context || {}),
    
    // Generation config
    config: {
      provider: result.provider || opts.provider,
      model: result.model || opts.model,
    },
    
    // Output
    output: result.code || result.output || null,
    
    // Quality scores
    scores: result.scores || result.validation || null,
    
    // Human notes
    tags: opts.tags || [],
    notes: opts.notes || '',
  };
}

/**
 * Remove personally identifiable info from context
 */
function anonymizeContext(ctx) {
  const safe = { ...ctx };
  // Remove location specifics
  if (safe.location) {
    safe.location = { country: safe.location.country || 'unknown' };
  }
  // Remove calendar details
  delete safe.calendar;
  // Remove health data
  delete safe.health;
  // Keep: time-of-day, weather summary, git topic
  return safe;
}

/**
 * Export spell pack to JSON file
 */
export function exportSpell(spell, outPath) {
  const dir = dirname(outPath);
  if (!existsSync(dir)) mkdirSync(dir, { recursive: true });
  writeFileSync(outPath, JSON.stringify(spell, null, 2), 'utf-8');
  return { path: outPath, size: Buffer.byteLength(JSON.stringify(spell)) };
}

/**
 * Import spell pack from JSON file
 */
export function importSpell(filePath) {
  const raw = readFileSync(filePath, 'utf-8');
  const spell = JSON.parse(raw);
  
  if (spell._format !== 'modus-forge-spell') {
    throw new Error(`Not a valid spell pack (got format: ${spell._format || 'none'})`);
  }
  
  return spell;
}

/**
 * Create a shareable text summary of a spell (for Telegram/Discord/etc.)
 */
export function spellToText(spell) {
  const lines = [
    `üîÆ **${spell.prompt}**`,
    '',
  ];
  
  if (spell.config?.provider) {
    lines.push(`‚ö° Provider: ${spell.config.provider}`);
  }
  
  if (spell.scores) {
    const s = spell.scores;
    const total = s.total ?? s.spinozaTotal ?? 
      ((s.conatus || 0) + (s.ratio || 0) + (s.laetitia || 0) + (s.natura || 0));
    lines.push(`üìä Spinoza: ${total}/40 (C:${s.conatus || '?'} R:${s.ratio || '?'} L:${s.laetitia || '?'} N:${s.natura || '?'})`);
  }
  
  if (spell.tags?.length) {
    lines.push(`üè∑Ô∏è ${spell.tags.join(', ')}`);
  }
  
  if (spell.notes) {
    lines.push(`üìù ${spell.notes}`);
  }
  
  lines.push('', `_Generated by MODUS Forge | ${spell.created?.split('T')[0] || 'unknown'}_`);
  
  return lines.join('\n');
}

/**
 * Create a minimal remix of a spell (keep prompt, clear output)
 */
export function remixSpell(spell, newOpts = {}) {
  return {
    ...spell,
    _version: SPELL_VERSION,
    created: new Date().toISOString(),
    author: newOpts.author || 'remixer',
    prompt: newOpts.prompt || spell.prompt,
    output: null,  // Clear output ‚Äî will be regenerated
    scores: null,
    notes: `Remixed from: ${spell.author} (${spell.created?.split('T')[0]})`,
    tags: [...(spell.tags || []), 'remix'],
  };
}
